<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="encoding" />
    <title>Critters</title>
    <style>
      #app {
        height: 600px;
        width: 800px;
        border: solid 1px black;
      }
    </style>

    <script>
      // Globals
      const maxWidth = 800;
      const maxHeight = 600;
      const collisionRadius = 2;
      var rendering = true;
      var collisionDebug = true;

      class Critter {
        constructor() {
          (this.id = Math.random() * 10000000000), // TODO: Replace with a UUID
            (this.team = {
              id: 1,
              colour: "#000000" // "#" + (((1 << 24) * Math.random()) | 0).toString(16)
            }),
            (this.position = {
              x: Math.ceil(Math.random() * maxWidth),
              y: Math.ceil(Math.random() * maxHeight)
            }),
            (this.speed = Math.ceil(Math.random() * 10)),
            (this.direction = Math.floor(Math.random() * 7)), // N, NE, E, SE, S, SW, W, NW
            (this.size = 5),
            (this.determineNextPosition = () => {
              return determineNextCritterPosition(this);
            }),
            (this.move = () => {
              this.position = this.determineNextPosition();
            }),
            (this.draw = () => {
              const ctx = canvas.getContext("2d");
              var circle = new Path2D();
              circle.arc(
                this.position.x,
                this.position.y,
                this.size,
                0,
                2 * Math.PI
              );
              ctx.fillStyle = this.team.colour;
              ctx.fill(circle);
              if (collisionDebug) {
                var debugCircle = new Path2D();
                debugCircle.arc(
                  this.position.x,
                  this.position.y,
                  10,
                  0,
                  2 * Math.PI
                );
                ctx.fillStyle = "rgba(255,0,0,0.2)";
                ctx.fill(debugCircle);
              }
              return;
            });
        }
      }

      var state = {
        critters: []
      };

      // TODO: change to trig functions if we want more directions
      const determineNextCritterPosition = critter => {
        switch (critter.direction) {
          case 0: //N
            return {
              x: critter.position.x,
              y:
                critter.position.y - critter.speed < 0
                  ? maxHeight
                  : critter.position.y - critter.speed
            };
            break;

          /*
                         /|
                     c  / | a
                       /  |
                      -----
                        b
                        c = 10
                        c^2 = b^2 + a^2 (if a == b)
                        c^2 = 2a^2
                        0.5(c^2) = a^2
                        a = sqrt(0.5*(c^2))
                      */

          case 1: //NE
            return {
              x:
                critter.position.x +
                  Math.sqrt(0.5 * (Math.pow(critter.speed), 2)) >
                maxWidth
                  ? maxWidth
                  : critter.position.x +
                    Math.sqrt(0.5 * (Math.pow(critter.speed), 2)),
              y:
                critter.position.y -
                  Math.sqrt(0.5 * (Math.pow(critter.speed), 2)) <
                0
                  ? maxHeight
                  : critter.position.y -
                    Math.sqrt(0.5 * (Math.pow(critter.speed), 2))
            };
            break;

          case 2: //E
            return {
              x:
                critter.position.x + critter.speed > maxWidth
                  ? 0
                  : critter.position.x + critter.speed,
              y: critter.position.y
            };
            break;

          case 3: //SE
            return {
              x:
                critter.position.x +
                  Math.sqrt(0.5 * (Math.pow(critter.speed), 2)) >
                maxWidth
                  ? 0
                  : critter.position.x +
                    Math.sqrt(0.5 * (Math.pow(critter.speed), 2)),
              y:
                critter.position.y +
                  Math.sqrt(0.5 * (Math.pow(critter.speed), 2)) >
                maxHeight
                  ? 0
                  : critter.position.y +
                    Math.sqrt(0.5 * (Math.pow(critter.speed), 2))
            };
            break;

          case 4: //S
            return {
              x: critter.position.x,
              y:
                critter.position.y + critter.speed > maxHeight
                  ? 0
                  : critter.position.y + critter.speed
            };
            break;

          case 5: //SW
            return {
              x:
                critter.position.x -
                  Math.sqrt(0.5 * (Math.pow(critter.speed), 2)) <
                0
                  ? maxWidth
                  : Math.sqrt(0.5 * (Math.pow(critter.speed), 2)),
              y:
                critter.position.y +
                  Math.sqrt(0.5 * (Math.pow(critter.speed), 2)) >
                maxHeight
                  ? 0
                  : critter.position.y +
                    Math.sqrt(0.5 * (Math.pow(critter.speed), 2))
            };
            break;

          case 6: //W
            return {
              x:
                critter.position.x - critter.speed < 0
                  ? maxWidth
                  : critter.position.x - critter.speed,
              y: critter.position.y
            };
            break;

          case 7: //NW
            return {
              x:
                critter.position.x -
                  Math.sqrt(0.5 * (Math.pow(critter.speed), 2)) <
                0
                  ? maxWidth
                  : critter.position.x -
                    Math.sqrt(0.5 * (Math.pow(critter.speed), 2)),
              y:
                critter.position.y -
                  Math.sqrt(0.5 * (Math.pow(critter.speed), 2)) <
                0
                  ? maxHeight
                  : critter.position.y -
                    Math.sqrt(0.5 * (Math.pow(critter.speed), 2))
            };
            break;

          default:
            return { x: critter.position.x, y: critter.position.y };
            break;
        }
      };

      generateTick = () => {
        setInterval(function() {
          document.dispatchEvent(new Event("tick"));
        }, 500);
      };

      clearCanvas = () => {
        const context = canvas.getContext("2d");
        context.clearRect(0, 0, canvas.width, canvas.height);
      };

      window.onkeypress = () => {
        console.log("rendering a frame");
        rendering = true;
      };

      handleInput = () => {};

      handleTick = () => {
        if (rendering) {
          clearCanvas();
          state.critters.forEach(c => {
            detectCollisions();
            c.move();
            c.draw();
          });
          rendering = false;
        }
      };

      isCollision = (a, b) => {
        var dx = a.position.x - b.position.x;
        var dy = a.position.y - b.position.y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        return distance < Math.floor(a.size) + Math.floor(b.size);
      };

      detectCollisions = () => {
        for (let i = 0; i < state.critters.length; i++) {
          for (let j = 0; j < state.critters.length; j++) {
            if (i == j) {
              continue;
            }
            if (isCollision(state.critters[i], state.critters[j])) {
              state.critters[i].team.colour = "#FF0000";
              state.critters[j].team.colour = "#FF0000";
            }
          }
        }
      };

      document.onreadystatechange = function() {
        if (document.readyState === "interactive") {
          for (let index = 0; index < 50; index++) {
            let x = new Critter();
            state.critters.push(x);
          }

          // Create clock
          generateTick();
          document.addEventListener("tick", handleTick, false);
        }
      };
    </script>
  </head>
  <body>
    <div id="header">
      <h1>Critters</h1>
    </div>
    <div id="app">
      <canvas id="canvas" height="600" width="800"> </canvas>
    </div>
  </body>
</html>
